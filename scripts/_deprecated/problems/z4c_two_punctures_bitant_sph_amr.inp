<job>

# Basename of output filenames.
problem_id = z4c
repository_info = code_development_a07324599c416c5612fa4d87ff7049ce612a0933

<z4c>

# # 1+log (moving puncture) gauge
# lapse_oplog = 2.0       # alpha_l
# lapse_harmonicf = 1.0   # alpha_hf
# lapse_harmonic = 0.0    # alpha_h
# lapse_advect = 1.0      # alpha_adv
# shift_Gamma = 1.0       # sigma_Gamma
# shift_eta = 2.0         # sigma_eta
# shift_alpha2Gamma = 0.0 # sigma_{alpha^2 Gamma}
# shift_H = 0.0           # sigma_H
# shift_advect = 1.0      # sigma_adv

## harmonic gauge
#lapse_oplog = 0.0       # alpha_l
#lapse_harmonicf = 0.0   # alpha_hf
#lapse_harmonic = 1.0    # alpha_h
#lapse_advect = 1.0      # alpha_adv
#shift_Gamma = 0.0       # sigma_Gamma
#shift_alpha2Gamma = 1.0 # sigma_{alpha^2 Gamma}
#shift_H = 1.0           # sigma_H
#shift_eta = 0.0         # sigma_eta
#shift_advect = 1.0      # sigma_adv

# 1+log (moving puncture) gauge
lapse_oplog = 2.0       # alpha_l
lapse_harmonicf = 1.0   # alpha_hf
lapse_harmonic = 0.0    # alpha_h
lapse_advect = 1.0      # alpha_adv
shift_Gamma = 1.0       # sigma_Gamma
shift_eta = 0.0         # sigma_eta
shift_alpha2Gamma = 0.0 # sigma_{alpha^2 Gamma}
shift_H = 0.0           # sigma_H
shift_advect = 1.0      # sigma_adv


# Kreiss-Oliger dissipation parameter.
diss = 0.02
chi_div_floor = 1e-5 # 1e-5
eps_floor = 1e-11

# Constraint damping factor 1.
damp_kappa1 = 0.02
# Constraint damping factor 2.
damp_kappa2 = 0.0

# Wave extraction
nrad_wave_extraction = 1
extraction_radius_0 = 10
extraction_radius_1 = 90
extraction_radius_2 = 100
extraction_radius_3 = 110
extraction_radius_4 = 120
extraction_radius_5 = 130
extraction_radius_6 = 140
extraction_nlev = 30
dt_wave_extraction = 0.56255
lmax = 8

# Puncture tracker
npunct = 2
bh_0_x = 3.257
bh_1_x = -3.257

bitant = true


# amr with spheres
sphere_zone_number = 1

# should roughly match the standard box-in-box

sphere_zone_level_0    = 2
sphere_zone_radius_0   = 100
sphere_zone_puncture_0 = -1  # not pinned to a puncture
sphere_zone_center1_0  = 0   # fix center
sphere_zone_center2_0  = 0
sphere_zone_center3_0  = 0

sphere_zone_level_1    = 8
sphere_zone_radius_1   = 1.5
sphere_zone_puncture_1 = 0  # pin to puncture

sphere_zone_level_2    = 8
sphere_zone_radius_2   = 1.5
sphere_zone_puncture_2 = 1  # pin to puncture

# twice radius in strong field, twice res. in wave-zone

sphere_zone_level_0    = 5
sphere_zone_radius_0   = 100
sphere_zone_puncture_0 = -1  # not pinned to a puncture
sphere_zone_center1_0  = 0   # fix center
sphere_zone_center2_0  = 0
sphere_zone_center3_0  = 0

sphere_zone_level_1    = 10
sphere_zone_radius_1   = 3
sphere_zone_puncture_1 = 0  # pin to puncture

sphere_zone_level_2    = 10
sphere_zone_radius_2   = 3
sphere_zone_puncture_2 = 1  # pin to puncture

<cce>

dump_every_dt = 1 ## a multiple of the time step
output_dir    = .

num_theta        = 41
num_phi          = 82
num_r_inshell    = 28
num_l_modes      = 7
num_radial_modes = 7

num_radii        = 3
rin_0            = 18
rout_0           = 22
rin_1            = 47
rout_1           = 53
rin_2            = 94
rout_2           = 106


<problem>

verbose = True

# x coordinate of the m+ puncture
par_b = 3.257
# mass of the m+ puncture
par_m_plus = 0.483
# mass of the m- puncture
par_m_minus = 0.483
# target ADM mass for m+
target_M_plus = 0.505
# target ADM mass for m-
target_M_minus = 0.505
# momentum of the m+ puncture
par_P_plus1 = 0.0
par_P_plus2 = 0.133
par_P_plus3 = 0.0
# momentum of the m- puncture
par_P_minus1 = 0.0
par_P_minus2 = -0.133
par_P_minus3 = 0.0

# spin of the m+ puncture
par_S_plus1 = 0.0
par_S_plus2 = 0.0
par_S_plus3 = 0.0
# spin of the m- puncture
par_S_minus1 = 0.0
par_S_minus2 = 0.0
par_S_minus3 = 0.0
# offset b=0 to position (x,y,z)
center_offset1 = 0.0
center_offset2 = 0.0
center_offset3 = 0.0
# User provides bare masses not target M_ADM
give_bare_mass = True
# No. coeff in the compactified radial dir.
npoints_A = 30
# No. coeff in the angular dir.
npoints_B = 30
# no. coeff in the phi dir.
npoints_phi = 24
# Tolerance for Newton solver
Newton_tol = 1e-10
# Maximum number of Newton iterations
Newton_maxit = 5
# A small number to smooth out singularities at punc. loc.
TP_epsilon = 0.0
# Tiny number to avoid nans near or at the puncture locations
TP_Tiny = 0.0
# Radius of an extended spacetime instead of the puncture
TP_Extend_radius = 0
# Tol. of ADM masses when give_bare_mass=no
adm_tol = 1e-10
do_residuum_debug_output = True
do_initial_debug_output = True
# Solve for momentum constraint?
solve_momentum_constraint = False
# Exponent n for psi^-n initial lapse profile (<0)
initial_lapse_psi_exponent = -2.0
# x<->z coord interchange during interp. (black holes become separated in z direction)
swap_xz = False
n_punct = 2

# impose bitant symmetry on ID directly through spectral interp. massage
impose_bitant_id = True

<ahf>

num_horizons     = 0
verbose      = 1

# First horizon at puncture 0
initial_radius_0 = 2.5
center_x_0 = 3.257
center_y_0 = 0.
center_z_0 = 0.
use_puncture_0 = 0 # This will override the pars above and initialize the horizon at the puncture
start_time_0 = 0.1
stop_time_0  = 500
compute_every_iter_0 = 3

# Second horizon at puncture 1
initial_radius_1 = 2.5
center_x_1 = -3.257
center_y_1 = 0.
center_z_1 = 0.
use_puncture_1 = 1 # This will override the pars above and initialize the horizon at the puncture
start_time_1 = 0.
stop_time_1  = 500
compute_every_iter_1 = 5

# Third horizon at the center
initial_radius_2 = 9.0
center_x_2 = 0.
center_y_2 = 0.
center_z_2 = 0.
start_time_2 = 0.
stop_time_2  = 500
compute_every_iter_2 = 2

<output1>
file_type = rst
dt = 5

# <output2>
# file_type = hdf5
# variable = weyl
# dt = 0.5
# data_format = %.16e
# ghost_zones = true
# x3_slice = 0

<output3>
file_type = hdf5
variable = z4c
dt = 0.25
data_format = %.16e
ghost_zones = true
x3_slice = 0
# 
# <output4>
# file_type = hdf5
# variable = adm
# dt = 1.5
# data_format = %.16e
# ghost_zones = true
# x3_slice = 0
# 
# <output5>
# file_type = hdf5
# variable = weyl
# dt = 1.5
# data_format = %.16e
# ghost_zones = true

<time>
cfl_number = 0.2
tlim = 1
integrator = rk4
ncycle_out = 1
nlim = -1

<mesh>

refinement = adaptive
num_threads = 12
# this just becomes an upper-bound with spherical refinement
numlevel = 20
deref_count = 0
# Number of zones in X1-direction
nx1 = 96
# Minimum value of X1
x1min = -384
# Maximum value of X1
x1max = 384
# Inner-X1 boundary flag
ix1_bc = extrapolate_outflow
# Outer-X1 boundary flag
ox1_bc = extrapolate_outflow
nx2 = 96
x2min = -384
x2max = 384
ix2_bc = extrapolate_outflow
ox2_bc = extrapolate_outflow
nx3 = 48
x3min = 0
x3max = 384
ix3_bc = reflecting
ox3_bc = extrapolate_outflow

<meshblock>

nx1 = 16
nx2 = 16
nx3 = 16
